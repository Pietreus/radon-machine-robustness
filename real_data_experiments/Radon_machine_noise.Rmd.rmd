---
title: "R Notebook"
output: html_notebook
---

The [R plugin](https://www.jetbrains.com/help/pycharm/r-plugin-support.html) for IntelliJ-based IDEs provides
handy capabilities to work with the [R Markdown](https://www.jetbrains.com/help/pycharm/r-markdown.html) files.
To [add](https://www.jetbrains.com/help/pycharm/r-markdown.html#add-code-chunk) a new R chunk,
position the caret at any line or the code chunk, then click "+".

The code chunk appears:
```{r aggregate_csvs}

library(dplyr)
library(readr)

merge_csv_fragments_by_name_base_r <- function(folder_A, folder_B) {
  # Get list of CSV fragment files in the source folder
  csv_files <- list.files(folder_A, pattern = "\\.csv\\.\\d+$", full.names = TRUE)

  # Extract base names and group files
  base_names <- gsub("\\.csv\\.\\d+$", "", basename(csv_files))
  file_groups <- split(csv_files, base_names)

  # Process each group
  for (base_name in names(file_groups)) {
    # Get the files for the current group and sort them by fragment number
    group_files <- file_groups[[base_name]]
    group_files <- group_files[order(as.numeric(gsub(".*\\.csv\\.(\\d+)$", "\\1", group_files)))]

    # Create an empty character vector to store the combined content
    combined_content <- character()

    # Read and concatenate all CSV fragments in the group
    for (file in group_files) {
      file_content <- readLines(file)
      combined_content <- c(combined_content, file_content)
    }

    # Remove duplicate header lines if present
    header <- combined_content[1]
    combined_content <- c(header, combined_content[-1][!duplicated(combined_content[-1])])

    # Define the output file path
    output_file_name <- paste0(base_name, ".csv")
    output_file_path <- file.path(folder_B, output_file_name)

    # Write the combined content to a CSV file in the destination folder
    writeLines(combined_content, output_file_path)

    message("CSV fragments for '", base_name, "' merged and saved to ", output_file_path)
  }
}

merge_csv_fragments("results","results_aggregated")

euclidean_distance <- function(vec1, vec2) {
  # Check if both vectors have the same length
  if (length(vec1) != length(vec2)) {
    stop("Vectors must have the same length.")
  }

  # Calculate the sum of squared differences
  sum_sq_diff <- sum((vec1 - vec2)^2)

  # Take the square root of the sum of squared differences
  dist <- sqrt(sum_sq_diff)

  return(dist)
}

```

Type any R code in the chunk, for example:
```{r}

library(tidyverse)

data <- read.csv("real_data_experiments/results_aggregated/hypothesis_flipping_under_noise_2024-06-10_14:27:38.csv")

params <- data$params

# Remove square brackets and split the string by whitespace
numeric_params <- (strsplit(gsub("\\[ ?|\\]", "", params), "\\s+"))
final_estimators <- do.call(rbind, lapply(numeric_params, as.numeric))

data


summary_data <- data %>%
  group_by(outliers,sigma) %>%
  summarise(
    mean_y = mean(auc),
    ci_low = pmax(mean(auc) - qt(0.975, df=n()-1) * sd(auc) / sqrt(n()), min(auc)),
    ci_high = pmin(mean(auc) + qt(0.975, df=n()-1) * sd(auc) / sqrt(n()), max(auc))
  )


library(ggplot2)

ggplot(data) +
        geom_smooth(aes(x=outliers, y=auc, color=as.factor(sigma)))

ggplot(summary_data, aes(x = outliers, y = mean_y)) +
  geom_line(aes(color = as.factor(sigma))) +
  geom_ribbon(aes(ymin = ci_low, ymax = ci_high, fill=as.factor(sigma)), alpha = 0.2) +
  # geom_point(data = data, aes(x = x, y = y), alpha = 0.1) + # optional: to show original data points
  labs(title = "Linear SVM Radon machine SUSY Dataset height=3",
       x = "Number of outliers",
       y = "ROC-AUC-score") +
  theme_minimal()


```

Now, click the **Run** button on the chunk toolbar to [execute](https://www.jetbrains.com/help/pycharm/r-markdown.html#run-r-code) the chunk code. The result should be placed under the chunk.
Click the **Knit and Open Document** to build and preview an output.
